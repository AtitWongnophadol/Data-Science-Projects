{\rtf1\ansi\ansicpg1252\cocoartf1671\cocoasubrtf100
{\fonttbl\f0\fswiss\fcharset0 Helvetica-Bold;\f1\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww16600\viewh12440\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\b\fs24 \cf0 1. Graph Analysis
\f1\b0 \
\
Write a script that can accept an adjacency matrix as input, and construct a node-based representation of a graph.  \
\
Next, write a method that takes two nodes as arguments, n1 and n2, and returns the number of nodes that are equidistant from n1 and n2.  These are the nodes for which the shortest paths to n1 and n2 have the same length.  Hint: run two breadth-first searches, one from n1 and one from n2.\
\
\
\pard\pardeftab720\sa240\partightenfactor0

\f0\b \cf0 \expnd0\expndtw0\kerning0
Submission 
\f1\b0 \
Submit your program as \'93graph.py\'94. Your program needs to read data from two files:\
1. File adj.txt \kerning1\expnd0\expndtw0 contains an adjacency matrix representing a graph.  Node 0 is represented by the first column and the first town, node 1 by the second column and the second row, and so forth.\expnd0\expndtw0\kerning0
\
2. File input.txt contains a list of pairs of nodes.  Each line contains one pair, the number of the first node and the number of the second node, separated by a space.\
In the main method of your script, read these files and generate an \'93output.txt\'94 file, in which the number of nodes equidistant to each pair are listed accordingly. We have attached examples of files for you to test your code before submission. Since your program may be tested using an auto-grader system, your code must replicate the given output.txt file exactly. In addition, please follow best coding practices to make your code easy to understand. \
\
\
\
\pard\pardeftab720\partightenfactor0

\fs20 \cf0 \kerning1\expnd0\expndtw0  You will use linear probing to resolve collisions. If a particular location in the table is filled, you move forward one space until an empty location is found. If you reach the end of the table, you cycle back to index 0.}